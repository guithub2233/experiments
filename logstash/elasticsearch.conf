input { 
  stdin { }
}

filter {
  multiline {
    pattern => "^\[%{TIMESTAMP_ISO8601:timestamp}\]"
    negate => true
    what => previous
  }

  grok {
    match => { "message" => "^\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{WORD:loglevel} *\]\[(?<component>[^ ]+) *\] \[(?<node>[^\]]+)\]+%{DATA:message}$" }
    overwrite => "message"
  }

  if [message] =~ /^ *\[gc\]/ {
    # Grok these 'gc' log messages...
    #logger.warn("[gc][{}][{}][{}] duration [{}], collections [{}]/[{}], total [{}]/[{}], memory [{}]->[{}]/[{}], all_pools {}",
                #gc.name(), seq, gc.collectionCount(), TimeValue.timeValueMillis(collectionTime), collections, TimeValue.timeValueMillis(currentJvmStats.timestamp() - lastJvmStats.timestamp()), TimeValue.timeValueMillis(collectionTime), gc.collectionTime(), lastJvmStats.mem().heapUsed(), currentJvmStats.mem().heapUsed(), JvmInfo.jvmInfo().mem().heapMax(), buildPools(lastJvmStats, currentJvmStats));
  }


  date {
    match => [ "timestamp", "YYYY-MM-dd HH:mm:ss,SSS" ]
    remove_field => "timestamp"
  }
}

output {
  stdout { codec => dots }
  elasticsearch {
    protocol => http
    host => localhost
  }
  #stdout { codec => rubydebug }
}
